<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=yrPxF2fzIbKO47OcVFfZ2CvhBULzVSj67-CyYQmQBzclLT34rKZNjX_x5wwcqB1FJcp4QFgPPqKvq4Bp_6u4rQ');ol{margin:0;padding:0}table td,table th{padding:0}.c13{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Economica";font-style:normal}.c20{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:30pt;font-family:"Economica";font-style:normal}.c27{margin-left:-0.8pt;padding-top:30pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c1{margin-left:-0.8pt;padding-top:10pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c11{margin-left:-0.8pt;padding-top:6pt;padding-bottom:6pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c3{color:#eeffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Courier New";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:30pt;font-family:"Economica";font-style:normal}.c22{margin-left:-0.8pt;padding-top:3pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c10{margin-left:-0.8pt;padding-top:6pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c9{color:#999999;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Open Sans";font-style:italic}.c4{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Open Sans";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Open Sans";font-style:normal}.c5{margin-left:-0.8pt;padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c16{font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Economica";font-style:normal}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c25{color:#000000;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Open Sans";font-style:normal}.c18{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c17{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c0{background-color:#f5f2f0;font-family:"Courier New";font-weight:400}.c12{color:#999999}.c19{color:#0077aa}.c23{font-style:italic}.c6{height:11pt}.c14{color:#669900}.c24{color:#9a6e3a}.c7{text-indent:0.8pt}.c21{font-weight:700}.c8{color:#990055}.title{padding-top:0pt;color:#000000;font-size:30pt;padding-bottom:0pt;font-family:"Economica";line-height:1.0;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#999999;font-size:14pt;padding-bottom:0pt;font-family:"Economica";line-height:1.0;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Open Sans"}p{margin:0;color:#000000;font-size:11pt;font-family:"Open Sans"}h1{padding-top:10pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:0pt;font-family:"Open Sans";line-height:1.5;orphans:2;widows:2;text-align:left}h2{padding-top:24pt;color:#000000;font-weight:700;font-size:13pt;padding-bottom:0pt;font-family:"Open Sans";line-height:1.0;orphans:2;widows:2;text-align:left}h3{padding-top:10pt;color:#8c7252;font-weight:700;font-size:12pt;padding-bottom:0pt;font-family:"Open Sans";line-height:1.5;orphans:2;widows:2;text-align:left}h4{padding-top:8pt;-webkit-text-decoration-skip:none;color:#666666;text-decoration:underline;font-size:11pt;padding-bottom:0pt;line-height:1.5;page-break-after:avoid;text-decoration-skip-ink:none;font-family:"Trebuchet MS";orphans:2;widows:2;text-align:left}h5{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.5;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.5;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c17"><div><p class="c6 c27 subtitle" id="h.leajue2ys1lr"><span class="c12 c16"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 2.67px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 2.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="horizontal line"></span></p></div><p class="c5 c6"><span class="c13"></span></p><p class="c7 c26 title" id="h.mbjsiz6n6jlo"><span class="c21">Breadth-First Search Algorithm</span></p><p class="c5 subtitle" id="h.vb8p0lepu9vn"><span class="c15">(Using Adjacency Matrix)</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c12">&nbsp;</span><span class="c12 c23">Rupam Jyoti Das</span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 4.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 4.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="horizontal line"></span></p><h1 class="c10" id="h.vydniszftb1n"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 622.50px; height: 444.93px;"><img alt="" src="images/image4.png" style="width: 622.50px; height: 478.62px; margin-left: 0.00px; margin-top: -16.85px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Placeholder image"></span></h1><h1 class="c1" id="h.arolcxe0i15c"><span>Introduction</span></h1><p class="c1 c7"><span class="c2">Breadth-First Search is an algorithm to traverse or search in a graph data structure. In this algorithm, we are given a vertex of the graph and we first traverse all the vertexes that are connected to that vertex, After that, do the same with all the vertexes that are connected with this vertex, and so on keep repeating until all the nodes that are connected to the starting given node (directly or indirectly) get visited.</span></p><p class="c1 c6 c7"><span class="c2"></span></p><p class="c1 c7"><span class="c2">What is the Adjacency Matrix representation of a graph?</span></p><p class="c1 c6 c7"><span class="c2"></span></p><p class="c1 c7"><span class="c2">Let&#39;s say we have the vertexes of a graph : (consider a list of characters, each character representing a vertex)</span></p><p class="c11 c7"><span class="c0 c12">[</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;A&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;B&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;C&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;D&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;E&#39;</span><span class="c0 c12 c18">]</span></p><p class="c1 c6 c7"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 377.33px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 377.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">Above you can see is a directed graph. To represent it using a matrix we can do it like this:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 377.33px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 377.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">In this above matrix, we put 1 when they are connected otherwise 0.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">The vertex A is connected with B, C, and D. So at the first row we have 1 bellow B, C, and D. The first row is for vertex A.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Similarly, for vertex B which is connected with D and E, we have 1 below D and E of the second row. Same for other vertexes.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Now for Breadth-first search:</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">If we start at A, (A is visited since it is the starting)</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">we will visit all its connected vertexes which are B, C, D.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Then we take B and visits its connected vertexes which are D and E. since D is already visited we ignore it.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Then we take C and try to visit its connected vertexes which is D only and since it is already visited we also ignore it.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Then moving to D we got E which is also visited so we ignore it as well.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">So finally we get:</span></p><p class="c11"><span class="c0 c8">A</span><span class="c0">&nbsp;</span><span class="c0 c8">B</span><span class="c0">&nbsp;</span><span class="c0 c8">C</span><span class="c0">&nbsp;</span><span class="c0 c8">D</span><span class="c0">&nbsp;</span><span class="c18 c0 c8">E</span></p><p class="c1"><span class="c2">as our visited nodes.</span></p><p class="c1"><span class="c2">Let&#39;s see the program now in C:</span></p><p class="c1"><span class="c2">We have a graph of total 5 vertexes which are:</span></p><p class="c11"><span class="c0 c19">char</span><span class="c0">&nbsp;vertexs</span><span class="c0 c12">[</span><span class="c0 c8">5</span><span class="c0 c12">]</span><span class="c0">&nbsp;</span><span class="c0 c24">=</span><span class="c0">&nbsp;</span><span class="c0 c12">{</span><span class="c0 c14">&#39;A&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;B&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;C&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;D&#39;</span><span class="c0 c12">,</span><span class="c0">&nbsp;</span><span class="c0 c14">&#39;E&#39;</span><span class="c18 c0 c12">};</span></p><p class="c1"><span class="c2">and the Adjacency Matrix</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; int adj[5][5] = {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; // A, B, C, D, E</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 1, 1, 1, 0}, // A</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 1, 1}, // B</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 1, 0}, // C</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 0, 1}, // D</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 0, 0} &nbsp;// E</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; };</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c4">Now The Function to implement BFS:</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;We will use a queue to implement it</span></p><p class="c1"><span class="c2">step:0-&gt; visit the starting vertex</span></p><p class="c1"><span class="c2">step:1-&gt; Take a queue and enqueue the starting vertex. </span></p><p class="c1"><span class="c2">step:2-&gt; dequeue from the array </span></p><p class="c1"><span class="c2">step:3-&gt; for this dequeued vertex, visit all the vertexes that are connected (ie 1) and are not visited.</span></p><p class="c1"><span class="c2">step:4-&gt; while visiting these vertexes enqueue them to the queue and marked as visited</span></p><p class="c1"><span class="c2">step:5-&gt; repeat step 1 up to 4 until the queue is empty</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c4">Now The function is:</span></p><p class="c1"><span class="c2">void BFS(const int size, char *vertexs, int adj[][size], int start)</span></p><p class="c1"><span class="c2">{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; // the queue to reference the vertex by holding the indices of &nbsp;vertex fron vertexs array</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; int queue[size];</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; int front = 0, rear = 0;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; //the array to keep track of the visited vertex by storing 1 at the position of the visited vertexes from vertexs array</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; int visited[size];</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; memset(visited, 0, size * sizeof(visited[0])); //initially none is visited so all are set to 0</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; //enqueue the index of the starter node</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; queue[rear] = start;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; //print the starter vertex</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; printf(&quot;%c &quot;, vertexs[start]);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; //mark starter vertex as visited</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; visited[start] = 1;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; while (front &lt;= rear) //until the queue is empty</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; { </span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; //dequeue &nbsp;the queue</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; int v = queue[front]; // v holds the position of the current vertex</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; front++;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 1; i &lt; size; i++) //travers the adjucency list for this node</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (adj[v][i] == 1 &amp;&amp; visited[i] == 0)</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%c &quot;, vertexs[i]);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //mark it as visited</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visited[i] = 1;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Enqueue the visited node &nbsp;so that we can get the adjucency list of it later</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rear++;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue[rear] = i;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">}</span></p><p class="c1"><span class="c4">We can use at as: </span></p><p class="c1"><span class="c2">int main()</span></p><p class="c1"><span class="c2">{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; char vertexs[SIZE] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;};</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; int adj[SIZE][SIZE] = {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; // A, B, C, D, E</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 1, 1, 1, 0}, // A</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 1, 1}, // B</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 1, 0}, // C</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 0, 1}, // D</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; {0, 0, 0, 0, 0} &nbsp;// E</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; };</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; BFS(SIZE, vertexs, adj, 3);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; return 0;</span></p><p class="c1"><span class="c2">}</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p></body></html>